/*
 * Copyright 2011 Peter Abeles
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package gecv.alg.filter.convolve.down;

import gecv.struct.convolve.Kernel1D_F32;
import gecv.struct.convolve.Kernel1D_I32;
import gecv.struct.convolve.Kernel2D_F32;
import gecv.struct.convolve.Kernel2D_I32;
import gecv.struct.image.*;


/**
 * <p>
 * Standard implementation of {@link gecv.alg.filter.convolve.ConvolveDownNoBorder} where no special
 * optimization has been done.
 * </p>
 *
 * <p>
 * DO NOT MODIFY: This class was automatically generated by {@link GenerateConvolveDownNoBorderStandard}.
 * </p>
 * 
 * @author Peter Abeles
 */
public class ConvolveDownNoBorderStandard {

	public static void horizontal( Kernel1D_F32 kernel ,
								   ImageFloat32 input, ImageFloat32 output ,
								   int skip ) {
		final float[] dataSrc = input.data;
		final float[] dataDst = output.data;
		final float[] dataKer = kernel.data;

		final int radius = kernel.getRadius();
		final int kernelWidth = kernel.getWidth();

		final int width = input.getWidth();
		final int height = input.getHeight();

		final int offsetX = radius <= skip ? skip : radius + radius % skip; 

		for( int i = 0; i < height; i++ ) {
			int indexDst = output.startIndex + i*output.stride + offsetX/skip;
			int j = input.startIndex+ i*input.stride;
			final int jEnd = j+width-radius;

			for( j += offsetX; j < jEnd; j += skip ) {
				float total = 0;
				int indexSrc = j-radius;
				for( int k = 0; k < kernelWidth; k++ ) {
					total += (dataSrc[indexSrc++] ) * dataKer[k];
				}

				dataDst[indexDst++] = total;
			}
		}
	}

	public static void vertical( Kernel1D_F32 kernel,
								 ImageFloat32 input, ImageFloat32 output,
								 int skip ) {
		final float[] dataSrc = input.data;
		final float[] dataDst = output.data;
		final float[] dataKer = kernel.data;

		final int radius = kernel.getRadius();
		final int kernelWidth = kernel.getWidth();

		final int imgWidth = input.getWidth();
		final int imgHeight = input.getHeight();

		final int yEnd = imgHeight-radius;

		final int offsetY = radius <= skip ? skip : radius + radius % skip;

		for( int y = offsetY; y < yEnd; y += skip ) {
			int indexDst = output.startIndex + (y/skip)*output.stride;
			int i = input.startIndex + y*input.stride;
			final int iEnd = i + imgWidth;

			for( ; i < iEnd; i++ ) {
				float total = 0;
				int indexSrc = i-radius*input.stride;
				for( int k = 0; k < kernelWidth; k++ ) {
					total += (dataSrc[indexSrc] ) * dataKer[k];
					indexSrc += input.stride;
				}

				dataDst[indexDst++] = total;
			}
		}
	}

	public static void convolve( Kernel2D_F32 kernel ,
								 ImageFloat32 input , ImageFloat32 output , int skip )
	{
		final float[] dataSrc = input.data;
		final float[] dataDst = output.data;
		final float[] dataKernel = kernel.data;

		final int width = input.getWidth();
		final int height = input.getHeight();

		final int radius = kernel.width/2;
		final int offset = radius <= skip ? skip : radius + radius % skip; 

		for( int y = offset; y < height-radius; y += skip ) {
			int indexDst = output.startIndex + (y/skip)*output.stride + offset/skip;
			for( int x = offset; x < width-radius; x += skip ) {
				float total = 0;
				int indexKer = 0;
				for( int ki = -radius; ki <= radius; ki++ ) {
					int indexSrc = input.startIndex+(y+ki)*input.stride+ x;
					for( int kj = -radius; kj <= radius; kj++ ) {
						total += (dataSrc[indexSrc+kj] )* dataKernel[indexKer++];
					}
				}
				dataDst[indexDst++] = total;
			}
		}
	}

	public static void horizontal( Kernel1D_I32 kernel ,
								   ImageUInt8 input, ImageInt16 output ,
								   int skip ) {
		final byte[] dataSrc = input.data;
		final short[] dataDst = output.data;
		final int[] dataKer = kernel.data;

		final int radius = kernel.getRadius();
		final int kernelWidth = kernel.getWidth();

		final int width = input.getWidth();
		final int height = input.getHeight();

		final int offsetX = radius <= skip ? skip : radius + radius % skip; 

		for( int i = 0; i < height; i++ ) {
			int indexDst = output.startIndex + i*output.stride + offsetX/skip;
			int j = input.startIndex+ i*input.stride;
			final int jEnd = j+width-radius;

			for( j += offsetX; j < jEnd; j += skip ) {
				int total = 0;
				int indexSrc = j-radius;
				for( int k = 0; k < kernelWidth; k++ ) {
					total += (dataSrc[indexSrc++] & 0xFF) * dataKer[k];
				}

				dataDst[indexDst++] = (short)total;
			}
		}
	}

	public static void vertical( Kernel1D_I32 kernel,
								 ImageUInt8 input, ImageInt16 output,
								 int skip ) {
		final byte[] dataSrc = input.data;
		final short[] dataDst = output.data;
		final int[] dataKer = kernel.data;

		final int radius = kernel.getRadius();
		final int kernelWidth = kernel.getWidth();

		final int imgWidth = input.getWidth();
		final int imgHeight = input.getHeight();

		final int yEnd = imgHeight-radius;

		final int offsetY = radius <= skip ? skip : radius + radius % skip;

		for( int y = offsetY; y < yEnd; y += skip ) {
			int indexDst = output.startIndex + (y/skip)*output.stride;
			int i = input.startIndex + y*input.stride;
			final int iEnd = i + imgWidth;

			for( ; i < iEnd; i++ ) {
				int total = 0;
				int indexSrc = i-radius*input.stride;
				for( int k = 0; k < kernelWidth; k++ ) {
					total += (dataSrc[indexSrc] & 0xFF) * dataKer[k];
					indexSrc += input.stride;
				}

				dataDst[indexDst++] = (short)total;
			}
		}
	}

	public static void convolve( Kernel2D_I32 kernel ,
								 ImageUInt8 input , ImageInt16 output , int skip )
	{
		final byte[] dataSrc = input.data;
		final short[] dataDst = output.data;
		final int[] dataKernel = kernel.data;

		final int width = input.getWidth();
		final int height = input.getHeight();

		final int radius = kernel.width/2;
		final int offset = radius <= skip ? skip : radius + radius % skip; 

		for( int y = offset; y < height-radius; y += skip ) {
			int indexDst = output.startIndex + (y/skip)*output.stride + offset/skip;
			for( int x = offset; x < width-radius; x += skip ) {
				int total = 0;
				int indexKer = 0;
				for( int ki = -radius; ki <= radius; ki++ ) {
					int indexSrc = input.startIndex+(y+ki)*input.stride+ x;
					for( int kj = -radius; kj <= radius; kj++ ) {
						total += (dataSrc[indexSrc+kj] & 0xFF)* dataKernel[indexKer++];
					}
				}
				dataDst[indexDst++] = (short)total;
			}
		}
	}

	public static void horizontal( Kernel1D_I32 kernel ,
								   ImageSInt16 input, ImageInt16 output ,
								   int skip ) {
		final short[] dataSrc = input.data;
		final short[] dataDst = output.data;
		final int[] dataKer = kernel.data;

		final int radius = kernel.getRadius();
		final int kernelWidth = kernel.getWidth();

		final int width = input.getWidth();
		final int height = input.getHeight();

		final int offsetX = radius <= skip ? skip : radius + radius % skip; 

		for( int i = 0; i < height; i++ ) {
			int indexDst = output.startIndex + i*output.stride + offsetX/skip;
			int j = input.startIndex+ i*input.stride;
			final int jEnd = j+width-radius;

			for( j += offsetX; j < jEnd; j += skip ) {
				int total = 0;
				int indexSrc = j-radius;
				for( int k = 0; k < kernelWidth; k++ ) {
					total += (dataSrc[indexSrc++] ) * dataKer[k];
				}

				dataDst[indexDst++] = (short)total;
			}
		}
	}

	public static void vertical( Kernel1D_I32 kernel,
								 ImageSInt16 input, ImageInt16 output,
								 int skip ) {
		final short[] dataSrc = input.data;
		final short[] dataDst = output.data;
		final int[] dataKer = kernel.data;

		final int radius = kernel.getRadius();
		final int kernelWidth = kernel.getWidth();

		final int imgWidth = input.getWidth();
		final int imgHeight = input.getHeight();

		final int yEnd = imgHeight-radius;

		final int offsetY = radius <= skip ? skip : radius + radius % skip;

		for( int y = offsetY; y < yEnd; y += skip ) {
			int indexDst = output.startIndex + (y/skip)*output.stride;
			int i = input.startIndex + y*input.stride;
			final int iEnd = i + imgWidth;

			for( ; i < iEnd; i++ ) {
				int total = 0;
				int indexSrc = i-radius*input.stride;
				for( int k = 0; k < kernelWidth; k++ ) {
					total += (dataSrc[indexSrc] ) * dataKer[k];
					indexSrc += input.stride;
				}

				dataDst[indexDst++] = (short)total;
			}
		}
	}

	public static void convolve( Kernel2D_I32 kernel ,
								 ImageSInt16 input , ImageInt16 output , int skip )
	{
		final short[] dataSrc = input.data;
		final short[] dataDst = output.data;
		final int[] dataKernel = kernel.data;

		final int width = input.getWidth();
		final int height = input.getHeight();

		final int radius = kernel.width/2;
		final int offset = radius <= skip ? skip : radius + radius % skip; 

		for( int y = offset; y < height-radius; y += skip ) {
			int indexDst = output.startIndex + (y/skip)*output.stride + offset/skip;
			for( int x = offset; x < width-radius; x += skip ) {
				int total = 0;
				int indexKer = 0;
				for( int ki = -radius; ki <= radius; ki++ ) {
					int indexSrc = input.startIndex+(y+ki)*input.stride+ x;
					for( int kj = -radius; kj <= radius; kj++ ) {
						total += (dataSrc[indexSrc+kj] )* dataKernel[indexKer++];
					}
				}
				dataDst[indexDst++] = (short)total;
			}
		}
	}

	public static void horizontal( Kernel1D_I32 kernel ,
								   ImageUInt8 input, ImageInt8 output ,
								   int skip , int divisor) {
		final byte[] dataSrc = input.data;
		final byte[] dataDst = output.data;
		final int[] dataKer = kernel.data;

		final int radius = kernel.getRadius();
		final int kernelWidth = kernel.getWidth();

		final int width = input.getWidth();
		final int height = input.getHeight();

		final int offsetX = radius <= skip ? skip : radius + radius % skip; 

		for( int i = 0; i < height; i++ ) {
			int indexDst = output.startIndex + i*output.stride + offsetX/skip;
			int j = input.startIndex+ i*input.stride;
			final int jEnd = j+width-radius;

			for( j += offsetX; j < jEnd; j += skip ) {
				int total = 0;
				int indexSrc = j-radius;
				for( int k = 0; k < kernelWidth; k++ ) {
					total += (dataSrc[indexSrc++] & 0xFF) * dataKer[k];
				}

				dataDst[indexDst++] = (byte)(total/divisor);
			}
		}
	}

	public static void vertical( Kernel1D_I32 kernel,
								 ImageUInt8 input, ImageInt8 output,
								 int skip , int divisor ) {
		final byte[] dataSrc = input.data;
		final byte[] dataDst = output.data;
		final int[] dataKer = kernel.data;

		final int radius = kernel.getRadius();
		final int kernelWidth = kernel.getWidth();

		final int imgWidth = input.getWidth();
		final int imgHeight = input.getHeight();

		final int yEnd = imgHeight-radius;

		final int offsetY = radius <= skip ? skip : radius + radius % skip;

		for( int y = offsetY; y < yEnd; y += skip ) {
			int indexDst = output.startIndex + (y/skip)*output.stride;
			int i = input.startIndex + y*input.stride;
			final int iEnd = i + imgWidth;

			for( ; i < iEnd; i++ ) {
				int total = 0;
				int indexSrc = i-radius*input.stride;
				for( int k = 0; k < kernelWidth; k++ ) {
					total += (dataSrc[indexSrc] & 0xFF) * dataKer[k];
					indexSrc += input.stride;
				}

				dataDst[indexDst++] = (byte)(total/divisor);
			}
		}
	}

	public static void convolve( Kernel2D_I32 kernel ,
								 ImageUInt8 input , ImageInt8 output , int skip , int divisor )
	{
		final byte[] dataSrc = input.data;
		final byte[] dataDst = output.data;
		final int[] dataKernel = kernel.data;

		final int width = input.getWidth();
		final int height = input.getHeight();

		final int radius = kernel.width/2;
		final int offset = radius <= skip ? skip : radius + radius % skip; 

		for( int y = offset; y < height-radius; y += skip ) {
			int indexDst = output.startIndex + (y/skip)*output.stride + offset/skip;
			for( int x = offset; x < width-radius; x += skip ) {
				int total = 0;
				int indexKer = 0;
				for( int ki = -radius; ki <= radius; ki++ ) {
					int indexSrc = input.startIndex+(y+ki)*input.stride+ x;
					for( int kj = -radius; kj <= radius; kj++ ) {
						total += (dataSrc[indexSrc+kj] & 0xFF)* dataKernel[indexKer++];
					}
				}
				dataDst[indexDst++] = (byte)(total/divisor);
			}
		}
	}

	public static void horizontal( Kernel1D_I32 kernel ,
								   ImageSInt16 input, ImageInt16 output ,
								   int skip , int divisor) {
		final short[] dataSrc = input.data;
		final short[] dataDst = output.data;
		final int[] dataKer = kernel.data;

		final int radius = kernel.getRadius();
		final int kernelWidth = kernel.getWidth();

		final int width = input.getWidth();
		final int height = input.getHeight();

		final int offsetX = radius <= skip ? skip : radius + radius % skip; 

		for( int i = 0; i < height; i++ ) {
			int indexDst = output.startIndex + i*output.stride + offsetX/skip;
			int j = input.startIndex+ i*input.stride;
			final int jEnd = j+width-radius;

			for( j += offsetX; j < jEnd; j += skip ) {
				int total = 0;
				int indexSrc = j-radius;
				for( int k = 0; k < kernelWidth; k++ ) {
					total += (dataSrc[indexSrc++] ) * dataKer[k];
				}

				dataDst[indexDst++] = (short)(total/divisor);
			}
		}
	}

	public static void vertical( Kernel1D_I32 kernel,
								 ImageSInt16 input, ImageInt16 output,
								 int skip , int divisor ) {
		final short[] dataSrc = input.data;
		final short[] dataDst = output.data;
		final int[] dataKer = kernel.data;

		final int radius = kernel.getRadius();
		final int kernelWidth = kernel.getWidth();

		final int imgWidth = input.getWidth();
		final int imgHeight = input.getHeight();

		final int yEnd = imgHeight-radius;

		final int offsetY = radius <= skip ? skip : radius + radius % skip;

		for( int y = offsetY; y < yEnd; y += skip ) {
			int indexDst = output.startIndex + (y/skip)*output.stride;
			int i = input.startIndex + y*input.stride;
			final int iEnd = i + imgWidth;

			for( ; i < iEnd; i++ ) {
				int total = 0;
				int indexSrc = i-radius*input.stride;
				for( int k = 0; k < kernelWidth; k++ ) {
					total += (dataSrc[indexSrc] ) * dataKer[k];
					indexSrc += input.stride;
				}

				dataDst[indexDst++] = (short)(total/divisor);
			}
		}
	}

	public static void convolve( Kernel2D_I32 kernel ,
								 ImageSInt16 input , ImageInt16 output , int skip , int divisor )
	{
		final short[] dataSrc = input.data;
		final short[] dataDst = output.data;
		final int[] dataKernel = kernel.data;

		final int width = input.getWidth();
		final int height = input.getHeight();

		final int radius = kernel.width/2;
		final int offset = radius <= skip ? skip : radius + radius % skip; 

		for( int y = offset; y < height-radius; y += skip ) {
			int indexDst = output.startIndex + (y/skip)*output.stride + offset/skip;
			for( int x = offset; x < width-radius; x += skip ) {
				int total = 0;
				int indexKer = 0;
				for( int ki = -radius; ki <= radius; ki++ ) {
					int indexSrc = input.startIndex+(y+ki)*input.stride+ x;
					for( int kj = -radius; kj <= radius; kj++ ) {
						total += (dataSrc[indexSrc+kj] )* dataKernel[indexKer++];
					}
				}
				dataDst[indexDst++] = (short)(total/divisor);
			}
		}
	}

}
