/*
 * Copyright (c) 2011-2012, Peter Abeles. All Rights Reserved.
 *
 * This file is part of BoofCV (http://www.boofcv.org).
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package boofcv.numerics.optimization.impl;

import boofcv.numerics.optimization.FunctionNtoN;
import boofcv.numerics.optimization.FunctionNtoS;
import boofcv.numerics.optimization.LineSearch;

/**
 * <p>
 * Manages data structures and simplifies line searches for nonlinear optimization.  A line search works by
 * searching a 1-dimensional subspace of an n-dimensional function for a local minimum.  A specialized
 * line search algorithm is passed in and is iterated until it converges to a solution.
 * </p>
 *
 * <p>
 * The gradient is not returned since only the derivative along the line search is computed.
 * </p>
 *
 * @author Peter Abeles
 */
public class LineSearchManager {

	// number of input parameters
	int N;
	
	// functions
	FunctionNtoS function;
	FunctionNtoN gradient;

	// initial derivative along the line
	double derivAtZero;

	// Line search functions
	LineStepFunction lineFunction;
	LineStepDerivative lineDerivative;

	// line search algorithm
	LineSearch search;

	// function value at the step at the end of the search
	double fstp;
	// minimum possible function value
	double funcMinValue;
	// gtol in wolfe condition
	double gtol;

	public LineSearchManager( LineSearch search , double funcMinValue , double gtol )
	{
		this.search = search;
		this.funcMinValue = funcMinValue;
		this.gtol = gtol;
	}

	/**
	 * Species the optimization function.
	 *
	 * @param function Function being optimized.
	 * @param gradient Specifies the gradient.  If null then the line's derivative will be numerically computed.
	 */
	public void setFunctions( FunctionNtoS function, FunctionNtoN gradient ) {
		this.function = function;
		this.lineFunction = new LineStepFunction(function);

		if( gradient != null ) {
			this.gradient = gradient;
			this.lineDerivative = new LineStepDerivative(gradient);
		} else {
			// todo handle null gradient
		}
		
		search.setFunction(lineFunction,lineDerivative);
		
		this.N = function.getN();
	}

	/**
	 *
	 * @param funcAtStart Function's value at startPoint.
	 * @param startPoint Sample point.
	 * @param startDeriv Gradient at startPoint.
	 * @param direction Direction of the search.
	 * @param initialStep Size of the initial step.  Typically 1.
	 */
	public void initialize( double funcAtStart , double[] startPoint , double[] startDeriv,
							double[] direction , double initialStep ) {
		// derivative of the line search is the dot product of the gradient and search direction
		derivAtZero = 0;
		for( int i = 0; i < N; i++ ) {
			derivAtZero += startDeriv[i]*direction[i];
		}

		lineFunction.setLine(startPoint,direction);
		double funcAtInit = lineFunction.process(initialStep);

		// use wolfe condition to set the maximum step size
		double maxStep = (funcMinValue-funcAtStart)/(gtol*derivAtZero);
		search.init(funcAtStart,derivAtZero,funcAtInit,initialStep,0,maxStep);
	}

	public double getLineDerivativeAtZero() {
		return derivAtZero;
	}
	
	public boolean iterate() {
		if( search.iterate() ) {

			// line search function caches the previous
			fstp = lineFunction.process(search.getStep());

			return true;
		}
		return false;
	}
	
	public boolean isSuccess() {
		return search.isConverged();
	}

	/**
	 * Step size at search termination
	 *
	 * @return final step
	 */
	public double getStep() {
		return search.getStep();
	}

	/**
	 * Warning messages generated by the search
	 *
	 * @return warning message
	 */
	public String getWarning() {
		return search.getWarning();
	}

	/**
	 * Function value at 'step'
	 */
	public double getFStep() {
		return fstp;
	}
}
