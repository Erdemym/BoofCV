/*
 * Copyright 2011 Peter Abeles
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package gecv.alg.wavelet.impl;

import gecv.alg.wavelet.UtilWavelet;
import gecv.core.image.border.BorderIndex1D;
import gecv.struct.image.ImageFloat32;
import gecv.struct.image.ImageSInt16;
import gecv.struct.image.ImageUInt8;
import gecv.struct.wavelet.WlBorderCoef;
import gecv.struct.wavelet.WlCoef_F32;
import gecv.struct.wavelet.WlCoef_I32;


/**
 * <p>
 * Performs the wavelet transform just around the image border.  Should be called in conjunction
 * with {@link ImplWaveletTransformInner} or similar functions.  Must be called after the inner
 * portion has been computed because the "inner" functions modify the border during the inverse
 * transform.
 * </p>
 *
 * <p>
 * For the inverse transform the inner transform must be called before the border is computed.
 * Due to how the inverse is computed some of the output values will be added to border.  The values
 * computed in these inverse functions add to that.
 * </p>
 * 
 * <p>
 * DO NOT MODIFY: This class was automatically generated by {@link gecv.alg.wavelet.impl.GenerateImplWaveletTransformBorder}
 * </p>
 *
 * @author Peter Abeles
 */
public class ImplWaveletTransformBorder {

	public static void horizontal( BorderIndex1D border , WlCoef_F32 coefficients , ImageFloat32 input , ImageFloat32 output )
	{
		final int offsetA = coefficients.offsetScaling;
		final int offsetB = coefficients.offsetWavelet;
		final float[] alpha = coefficients.scaling;
		final float[] beta = coefficients.wavelet;

		border.setLength(output.width);

		final boolean isLarger = output.width > input.width;
		final int width = output.width;
		final int height = input.height;
		final int lowerBorder = UtilWavelet.borderForwardLower(coefficients);
		final int upperBorder = input.width - input.width%2 - UtilWavelet.borderForwardUpper(coefficients);

		for( int y = 0; y < height; y++ ) {
			for( int x = 0; x < lowerBorder; x += 2 ) {
				float scale = 0;
				float wavelet = 0;

				for( int i = 0; i < alpha.length; i++ ) {
					int xx = border.getIndex(x+i+offsetA);
					if( isLarger && xx >= input.width )
						continue;
					scale += input.get(xx,y)*alpha[i];
				}
				for( int i = 0; i < beta.length; i++ ) {
					int xx = border.getIndex(x+i+offsetB);
					if( isLarger && xx >= input.width )
						continue;
					wavelet += input.get(xx,y)*beta[i];
				}

				int outX = x/2;

				output.set(outX,y,scale);
				output.set(width/2 + outX , y , wavelet );
			}
			for( int x = upperBorder; x < width; x += 2 ) {
				float scale = 0;
				float wavelet = 0;

				for( int i = 0; i < alpha.length; i++ ) {
					int xx = border.getIndex(x+i+offsetA);
					if( isLarger && xx >= input.width )
						continue;
					scale += input.get(xx,y)*alpha[i];
				}
				for( int i = 0; i < beta.length; i++ ) {
					int xx = border.getIndex(x+i+offsetB);
					if( isLarger && xx >= input.width )
						continue;
					wavelet += input.get(xx,y)*beta[i];
				}

				int outX = x/2;

				output.set(outX,y,scale);
				output.set(width/2 + outX , y , wavelet );
			}
		}
	}

	public static void vertical( BorderIndex1D border , WlCoef_F32 coefficients , ImageFloat32 input , ImageFloat32 output )
	{
		final int offsetA = coefficients.offsetScaling;
		final int offsetB = coefficients.offsetWavelet;
		final float[] alpha = coefficients.scaling;
		final float[] beta = coefficients.wavelet;

		border.setLength(output.height);

		final boolean isLarger = output.height > input.height;
		final int width = input.width;
		final int height = output.height;
		final int lowerBorder = UtilWavelet.borderForwardLower(coefficients);
		final int upperBorder = input.height - input.height%2 - UtilWavelet.borderForwardUpper(coefficients);

		for( int x = 0; x < width; x++) {
			for( int y = 0; y < lowerBorder; y += 2 ) {
				float scale = 0;
				float wavelet = 0;

				for( int i = 0; i < alpha.length; i++ ) {
					int yy = border.getIndex(y+i+offsetA);
					if( isLarger && yy >= input.height )
						continue;
					scale += input.get(x,yy)*alpha[i];
				}
				for( int i = 0; i < beta.length; i++ ) {
					int yy = border.getIndex(y+i+offsetB);
					if( isLarger && yy >= input.height )
						continue;
					wavelet += input.get(x,yy)*beta[i];
				}

				int outY = y/2;

				output.set(x , outY,scale);
				output.set(x , height/2 + outY , wavelet );
			}

			for( int y = upperBorder; y < height; y += 2 ) {
				float scale = 0;
				float wavelet = 0;

				for( int i = 0; i < alpha.length; i++ ) {
					int yy = border.getIndex(y+i+offsetA);
					if( isLarger && yy >= input.height )
						continue;
					scale += input.get(x,yy)*alpha[i];
				}
				for( int i = 0; i < beta.length; i++ ) {
					int yy = border.getIndex(y+i+offsetB);
					if( isLarger && yy >= input.height )
						continue;
					wavelet += input.get(x,yy)*beta[i];
				}

				int outY = y/2;

				output.set(x , outY,scale);
				output.set(x , height/2 + outY , wavelet );
			}
		}
	}

	public static void horizontalInverse( BorderIndex1D border , WlBorderCoef<WlCoef_F32> desc , ImageFloat32 input , ImageFloat32 output )
	{
		float []trends = new float[ input.width ];
		float []details = new float[ input.width ];

		final int width = input.width;
		final int height = output.height;
		final int paddedWidth = output.width + output.width%2;

		int lowerBorder = UtilWavelet.borderInverseLower(desc)/2;
		int upperBorder = output.width%2 + UtilWavelet.borderInverseUpper(desc)/2;

		int indexes[] = new int[lowerBorder+upperBorder];
		for( int i = 0; i < lowerBorder; i++ )
			indexes[i] = i*2;
		for( int i = lowerBorder; i < indexes.length; i++ )
			indexes[i] = paddedWidth-(indexes.length-i)*2;

		border.setLength(input.width);

		for( int y = 0; y < height; y++ ) {

			// initialize details and trends arrays
			for( int i = 0; i < indexes.length; i++ ) {
				int x = indexes[i];
				details[x] = 0; trends[x] = 0;
				x++;
				details[x] = 0; trends[x] = 0;
			}

			for( int i = 0; i < indexes.length; i++ ) {
				int x = indexes[i];
				WlCoef_F32 coef;
				if( x < desc.getLowerLength()*2 )
					coef = desc.getBorderCoefficients(x);
				else
					coef = desc.getBorderCoefficients(x-paddedWidth);

				int s = coef.offsetScaling; s -= s%2;
				int e = coef.getScalingLength()+coef.offsetScaling;

				for( int j = s; j < e; j += 2 ) {
					int xx = border.getIndex(x-j);
					trends[x] += input.get(xx/2,y)*coef.scaling[j-coef.offsetScaling];
				}

				s = coef.offsetScaling-1; s -= s%2;
				e = coef.getScalingLength()+coef.offsetScaling-1;

				for( int j = s; j < e; j += 2 ) {
					int xx = border.getIndex(x-j);
					trends[x+1] += input.get(xx/2,y)*coef.scaling[j-coef.offsetScaling+1];
				}

				s = coef.offsetScaling; s -= s%2;
				e = coef.getWaveletLength()+coef.offsetWavelet;

				for( int j = s; j < e; j += 2 ) {
					int xx = border.getIndex(x-j);
					details[x] += input.get(xx/2+width/2,y)*coef.wavelet[j-coef.offsetWavelet];
				}

				s = coef.offsetScaling-1; s -= s%2;
				e = coef.getWaveletLength()+coef.offsetWavelet-1;

				for( int j = s; j < e; j += 2 ) {
					int xx = border.getIndex(x-j+1);
					details[x+1] += input.get(xx/2+width/2,y)*coef.wavelet[j-coef.offsetWavelet+1];
				}
			}

			int indexDst = output.startIndex + y*output.stride;
			for( int i = 0; i < indexes.length; i++ ) {
				int x = indexes[i];
				output.data[ indexDst + x ] = (trends[x] + details[x]);
				x++;
				if( x >= output.width )
					continue;
				output.data[ indexDst + x ] = (trends[x] + details[x]);
			}
		}
	}

	public static void verticalInverse( BorderIndex1D border , WlBorderCoef<WlCoef_F32> desc , ImageFloat32 input , ImageFloat32 output )
	{
		float []trends = new float[ input.height ];
		float []details = new float[ input.height ];

		final int width = output.width;
		final int height = input.height;
		final int paddedHeight = output.height + output.height%2;

		int lowerBorder = UtilWavelet.borderInverseLower(desc)/2;
		int upperBorder = output.height%2 + UtilWavelet.borderInverseUpper(desc)/2;

		int indexes[] = new int[lowerBorder+upperBorder];
		for( int i = 0; i < lowerBorder; i++ )
			indexes[i] = i*2;
		for( int i = lowerBorder; i < indexes.length; i++ )
			indexes[i] = paddedHeight-(indexes.length-i)*2;

		border.setLength(input.height);

		for( int x = 0; x < width; x++ ) {

			// initialize details and trends arrays
			for( int i = 0; i < indexes.length; i++ ) {
				int y = indexes[i];
				details[y] = 0; trends[y] = 0;
				y++;
				details[y] = 0; trends[y] = 0;
			}

			for( int i = 0; i < indexes.length; i++ ) {
				int y = indexes[i];
				WlCoef_F32 coef;
				if( y < desc.getLowerLength()*2 )
					coef = desc.getBorderCoefficients(y);
				else
					coef = desc.getBorderCoefficients(y-paddedHeight);

				int s = coef.offsetScaling; s -= s%2;
				int e = coef.getScalingLength()+coef.offsetScaling;

				for( int j = s; j < e; j += 2 ) {
					int yy = border.getIndex(y-j);
					trends[y] += input.get(x,yy/2)*coef.scaling[j-coef.offsetScaling];
				}

				s = coef.offsetScaling-1; s -= s%2;
				e = coef.getScalingLength()+coef.offsetScaling-1;

				for( int j = s; j < e; j += 2 ) {
					int yy = border.getIndex(y-j);
					trends[y+1] += input.get(x,yy/2)*coef.scaling[j-coef.offsetScaling+1];
				}

				s = coef.offsetScaling; s -= s%2;
				e = coef.getWaveletLength()+coef.offsetWavelet;

				for( int j = s; j < e; j += 2 ) {
					int yy = border.getIndex(y-j);
					details[y] += input.get(x,yy/2+height/2)*coef.wavelet[j-coef.offsetWavelet];
				}

				s = coef.offsetScaling-1; s -= s%2;
				e = coef.getWaveletLength()+coef.offsetWavelet-1;

				for( int j = s; j < e; j += 2 ) {
					int yy = border.getIndex(y-j+1);
					details[y+1] += input.get(x,yy/2+height/2)*coef.wavelet[j-coef.offsetWavelet+1];
				}
			}

			int indexDst = output.startIndex + x;
			for( int i = 0; i < indexes.length; i++ ) {
				int y = indexes[i];
				output.data[ indexDst + y*output.stride ] = (trends[y] + details[y]);
				y++;
				if( y >= output.height )
					continue;
				output.data[ indexDst + y*output.stride ] = (trends[y] + details[y]);
			}
		}
	}

	public static void horizontal( BorderIndex1D border , WlCoef_I32 coefficients , ImageUInt8 input , ImageSInt16 output )
	{
		final int offsetA = coefficients.offsetScaling;
		final int offsetB = coefficients.offsetWavelet;
		final int[] alpha = coefficients.scaling;
		final int[] beta = coefficients.wavelet;

		border.setLength(output.width);

		final boolean isLarger = output.width > input.width;
		final int width = output.width;
		final int height = input.height;
		final int lowerBorder = UtilWavelet.borderForwardLower(coefficients);
		final int upperBorder = input.width - input.width%2 - UtilWavelet.borderForwardUpper(coefficients);

		for( int y = 0; y < height; y++ ) {
			for( int x = 0; x < lowerBorder; x += 2 ) {
				int scale = 0;
				int wavelet = 0;

				for( int i = 0; i < alpha.length; i++ ) {
					int xx = border.getIndex(x+i+offsetA);
					if( isLarger && xx >= input.width )
						continue;
					scale += input.get(xx,y)*alpha[i];
				}
				for( int i = 0; i < beta.length; i++ ) {
					int xx = border.getIndex(x+i+offsetB);
					if( isLarger && xx >= input.width )
						continue;
					wavelet += input.get(xx,y)*beta[i];
				}

				scale = 2*scale/coefficients.denominatorScaling;
				wavelet = 2*wavelet/coefficients.denominatorWavelet;

				int outX = x/2;

				output.set(outX,y,scale);
				output.set(width/2 + outX , y , wavelet );
			}
			for( int x = upperBorder; x < width; x += 2 ) {
				int scale = 0;
				int wavelet = 0;

				for( int i = 0; i < alpha.length; i++ ) {
					int xx = border.getIndex(x+i+offsetA);
					if( isLarger && xx >= input.width )
						continue;
					scale += input.get(xx,y)*alpha[i];
				}
				for( int i = 0; i < beta.length; i++ ) {
					int xx = border.getIndex(x+i+offsetB);
					if( isLarger && xx >= input.width )
						continue;
					wavelet += input.get(xx,y)*beta[i];
				}

				int outX = x/2;

				scale = 2*scale/coefficients.denominatorScaling;
				wavelet = 2*wavelet/coefficients.denominatorWavelet;

				output.set(outX,y,scale);
				output.set(width/2 + outX , y , wavelet );
			}
		}
	}

	public static void vertical( BorderIndex1D border , WlCoef_I32 coefficients , ImageUInt8 input , ImageSInt16 output )
	{
		final int offsetA = coefficients.offsetScaling;
		final int offsetB = coefficients.offsetWavelet;
		final int[] alpha = coefficients.scaling;
		final int[] beta = coefficients.wavelet;

		border.setLength(output.height);

		final boolean isLarger = output.height > input.height;
		final int width = input.width;
		final int height = output.height;
		final int lowerBorder = UtilWavelet.borderForwardLower(coefficients);
		final int upperBorder = input.height - input.height%2 - UtilWavelet.borderForwardUpper(coefficients);

		for( int x = 0; x < width; x++) {
			for( int y = 0; y < lowerBorder; y += 2 ) {
				int scale = 0;
				int wavelet = 0;

				for( int i = 0; i < alpha.length; i++ ) {
					int yy = border.getIndex(y+i+offsetA);
					if( isLarger && yy >= input.height )
						continue;
					scale += input.get(x,yy)*alpha[i];
				}
				for( int i = 0; i < beta.length; i++ ) {
					int yy = border.getIndex(y+i+offsetB);
					if( isLarger && yy >= input.height )
						continue;
					wavelet += input.get(x,yy)*beta[i];
				}

				int outY = y/2;

				scale = 2*scale/coefficients.denominatorScaling;
				wavelet = 2*wavelet/coefficients.denominatorWavelet;

				output.set(x , outY,scale);
				output.set(x , height/2 + outY , wavelet );
			}

			for( int y = upperBorder; y < height; y += 2 ) {
				int scale = 0;
				int wavelet = 0;

				for( int i = 0; i < alpha.length; i++ ) {
					int yy = border.getIndex(y+i+offsetA);
					if( isLarger && yy >= input.height )
						continue;
					scale += input.get(x,yy)*alpha[i];
				}
				for( int i = 0; i < beta.length; i++ ) {
					int yy = border.getIndex(y+i+offsetB);
					if( isLarger && yy >= input.height )
						continue;
					wavelet += input.get(x,yy)*beta[i];
				}

				int outY = y/2;

				scale = 2*scale/coefficients.denominatorScaling;
				wavelet = 2*wavelet/coefficients.denominatorWavelet;

				output.set(x , outY,scale);
				output.set(x , height/2 + outY , wavelet );
			}
		}
	}

	public static void horizontalInverse( BorderIndex1D border , WlBorderCoef<WlCoef_I32> desc , ImageUInt8 input , ImageSInt16 output )
	{
		int []trends = new int[ input.width ];
		int []details = new int[ input.width ];

		final int width = input.width;
		final int height = output.height;
		final int paddedWidth = output.width + output.width%2;

		int lowerBorder = UtilWavelet.borderInverseLower(desc)/2;
		int upperBorder = output.width%2 + UtilWavelet.borderInverseUpper(desc)/2;

		int indexes[] = new int[lowerBorder+upperBorder];
		for( int i = 0; i < lowerBorder; i++ )
			indexes[i] = i*2;
		for( int i = lowerBorder; i < indexes.length; i++ )
			indexes[i] = paddedWidth-(indexes.length-i)*2;

		border.setLength(input.width);

		for( int y = 0; y < height; y++ ) {

			// initialize details and trends arrays
			for( int i = 0; i < indexes.length; i++ ) {
				int x = indexes[i];
				details[x] = 0; trends[x] = 0;
				x++;
				details[x] = 0; trends[x] = 0;
			}

			for( int i = 0; i < indexes.length; i++ ) {
				int x = indexes[i];
				WlCoef_I32 coef;
				if( x < desc.getLowerLength()*2 )
					coef = desc.getBorderCoefficients(x);
				else
					coef = desc.getBorderCoefficients(x-paddedWidth);

				int s = coef.offsetScaling; s -= s%2;
				int e = coef.getScalingLength()+coef.offsetScaling;

				for( int j = s; j < e; j += 2 ) {
					int xx = border.getIndex(x-j);
					trends[x] += input.get(xx/2,y)*coef.scaling[j-coef.offsetScaling];
				}

				s = coef.offsetScaling-1; s -= s%2;
				e = coef.getScalingLength()+coef.offsetScaling-1;

				for( int j = s; j < e; j += 2 ) {
					int xx = border.getIndex(x-j);
					trends[x+1] += input.get(xx/2,y)*coef.scaling[j-coef.offsetScaling+1];
				}

				s = coef.offsetScaling; s -= s%2;
				e = coef.getWaveletLength()+coef.offsetWavelet;

				for( int j = s; j < e; j += 2 ) {
					int xx = border.getIndex(x-j);
					details[x] += input.get(xx/2+width/2,y)*coef.wavelet[j-coef.offsetWavelet];
				}

				s = coef.offsetScaling-1; s -= s%2;
				e = coef.getWaveletLength()+coef.offsetWavelet-1;

				for( int j = s; j < e; j += 2 ) {
					int xx = border.getIndex(x-j+1);
					details[x+1] += input.get(xx/2+width/2,y)*coef.wavelet[j-coef.offsetWavelet+1];
				}
			}

			int indexDst = output.startIndex + y*output.stride;
			for( int i = 0; i < indexes.length; i++ ) {
				int x = indexes[i];
				WlCoef_I32 coef;
				if( x < desc.getLowerLength()*2 )
					coef = desc.getBorderCoefficients(x);
				else
					coef = desc.getBorderCoefficients(x-paddedWidth);

				final int e = coef.denominatorScaling*2;
				final int f = coef.denominatorWavelet*2;
				final int ef = e*f;
				final int ef2 = ef/2;

				output.data[ indexDst + x ] = (short)((trends[x]*f + details[x]*e + ef2)/ef);
				x++;
				if( x >= output.width )
					continue;
				output.data[ indexDst + x ] = (short)((trends[x]*f + details[x]*e + ef2)/ef);
			}
		}
	}

	public static void verticalInverse( BorderIndex1D border , WlBorderCoef<WlCoef_I32> desc , ImageUInt8 input , ImageSInt16 output )
	{
		int []trends = new int[ input.height ];
		int []details = new int[ input.height ];

		final int width = output.width;
		final int height = input.height;
		final int paddedHeight = output.height + output.height%2;

		int lowerBorder = UtilWavelet.borderInverseLower(desc)/2;
		int upperBorder = output.height%2 + UtilWavelet.borderInverseUpper(desc)/2;

		int indexes[] = new int[lowerBorder+upperBorder];
		for( int i = 0; i < lowerBorder; i++ )
			indexes[i] = i*2;
		for( int i = lowerBorder; i < indexes.length; i++ )
			indexes[i] = paddedHeight-(indexes.length-i)*2;

		border.setLength(input.height);

		for( int x = 0; x < width; x++ ) {

			// initialize details and trends arrays
			for( int i = 0; i < indexes.length; i++ ) {
				int y = indexes[i];
				details[y] = 0; trends[y] = 0;
				y++;
				details[y] = 0; trends[y] = 0;
			}

			for( int i = 0; i < indexes.length; i++ ) {
				int y = indexes[i];
				WlCoef_I32 coef;
				if( y < desc.getLowerLength()*2 )
					coef = desc.getBorderCoefficients(y);
				else
					coef = desc.getBorderCoefficients(y-paddedHeight);

				int s = coef.offsetScaling; s -= s%2;
				int e = coef.getScalingLength()+coef.offsetScaling;

				for( int j = s; j < e; j += 2 ) {
					int yy = border.getIndex(y-j);
					trends[y] += input.get(x,yy/2)*coef.scaling[j-coef.offsetScaling];
				}

				s = coef.offsetScaling-1; s -= s%2;
				e = coef.getScalingLength()+coef.offsetScaling-1;

				for( int j = s; j < e; j += 2 ) {
					int yy = border.getIndex(y-j);
					trends[y+1] += input.get(x,yy/2)*coef.scaling[j-coef.offsetScaling+1];
				}

				s = coef.offsetScaling; s -= s%2;
				e = coef.getWaveletLength()+coef.offsetWavelet;

				for( int j = s; j < e; j += 2 ) {
					int yy = border.getIndex(y-j);
					details[y] += input.get(x,yy/2+height/2)*coef.wavelet[j-coef.offsetWavelet];
				}

				s = coef.offsetScaling-1; s -= s%2;
				e = coef.getWaveletLength()+coef.offsetWavelet-1;

				for( int j = s; j < e; j += 2 ) {
					int yy = border.getIndex(y-j+1);
					details[y+1] += input.get(x,yy/2+height/2)*coef.wavelet[j-coef.offsetWavelet+1];
				}
			}

			int indexDst = output.startIndex + x;
			for( int i = 0; i < indexes.length; i++ ) {
				int y = indexes[i];
				WlCoef_I32 coef;
				if( y < desc.getLowerLength()*2 )
					coef = desc.getBorderCoefficients(y);
				else
					coef = desc.getBorderCoefficients(y-paddedHeight);
				final int e = coef.denominatorScaling*2;
				final int f = coef.denominatorWavelet*2;
				final int ef = e*f;
				final int ef2 = ef/2;

				output.data[ indexDst + y*output.stride ] = (short)((trends[y]*f + details[y]*e + ef2)/ef);
				y++;
				if( y >= output.height )
					continue;
				output.data[ indexDst + y*output.stride ] = (short)((trends[y]*f + details[y]*e + ef2)/ef);
			}
		}
	}


}
